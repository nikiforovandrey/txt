z_workgp1:--z_workgp1
declare @t_date nvarchar(30)
declare @isordes nvarchar(50)
set @t_date = case when '#non' = [2] then '' else  [2] end
set @isordes = case when '#non' = [3] then '' else  [3] end

--分週(取最小和最大預交日)
declare @tmp table(
	idno int identity(1,1),
	week int,
	bweek nvarchar(50),
	eweek nvarchar(50)
)

declare @minday nvarchar(10)=(select MIN(datea)minday from view_ordes[1] where datea>@t_date and productno in (select noa from uca) )
--取當週的第一天
declare @mindayweeks int=-1*(select DATEPART(WEEKDAY, CONVERT(datetime ,CONVERT(nvarchar(10),CONVERT(int,left(@minday,3))+1911)+right(left(@minday,6),2)+right(@minday,2)))-1)
set @minday=left(right('0'+CONVERT (nvarchar(7),CONVERT (VARCHAR(7),dateadd(d,@mindayweeks,CONVERT(datetime ,CONVERT(nvarchar(10),CONVERT(int,left(@minday,3))+1911)+right(left(@minday,6),2)+right(@minday,2)) ),12 )+0890000),7),3)+'/'
				+right(left(right('0'+CONVERT (nvarchar(7),CONVERT (VARCHAR(7),dateadd(d,@mindayweeks,CONVERT(datetime ,CONVERT(nvarchar(10),CONVERT(int,left(@minday,3))+1911)+right(left(@minday,6),2)+right(@minday,2)) ),12 )+0890000),7),5),2)+'/'
				+right(right('0'+CONVERT (nvarchar(7),CONVERT (VARCHAR(7),dateadd(d,@mindayweeks,CONVERT(datetime ,CONVERT(nvarchar(10),CONVERT(int,left(@minday,3))+1911)+right(left(@minday,6),2)+right(@minday,2)) ),12 )+0890000),7),2)

declare @maxday nvarchar(10)=(select MAX(datea)maxday from view_ordes[1] where datea>@t_date and productno in (select noa from uca) )
declare @t_minday nvarchar(10)
while(@minday<=@maxday)
begin
	set @t_minday=left(right('0'+CONVERT (nvarchar(7),CONVERT (VARCHAR(7),dateadd(d,6,CONVERT(datetime ,CONVERT(nvarchar(10),CONVERT(int,left(@minday,3))+1911)+right(left(@minday,6),2)+right(@minday,2)) ),12 )+0890000),7),3)+'/'
				+right(left(right('0'+CONVERT (nvarchar(7),CONVERT (VARCHAR(7),dateadd(d,6,CONVERT(datetime ,CONVERT(nvarchar(10),CONVERT(int,left(@minday,3))+1911)+right(left(@minday,6),2)+right(@minday,2)) ),12 )+0890000),7),5),2)+'/'
				+right(right('0'+CONVERT (nvarchar(7),CONVERT (VARCHAR(7),dateadd(d,6,CONVERT(datetime ,CONVERT(nvarchar(10),CONVERT(int,left(@minday,3))+1911)+right(left(@minday,6),2)+right(@minday,2)) ),12 )+0890000),7),2)
	insert into @tmp
	select datepart(week,CONVERT(nvarchar(10),CONVERT(int,left(@minday,3))+1911)+right(left(@minday,6),2)+right(@minday,2))-datepart(week,dateadd(month,datediff(month,0,CONVERT(nvarchar(10),CONVERT(int,left(@minday,3))+1911)+right(left(@minday,6),2)+right(@minday,2)),0))+1 
	,@minday,@t_minday
	set @minday=left(right('0'+CONVERT (nvarchar(7),CONVERT (VARCHAR(7),dateadd(d,7,CONVERT(datetime ,CONVERT(nvarchar(10),CONVERT(int,left(@minday,3))+1911)+right(left(@minday,6),2)+right(@minday,2)) ),12 )+0890000),7),3)+'/'
				+right(left(right('0'+CONVERT (nvarchar(7),CONVERT (VARCHAR(7),dateadd(d,7,CONVERT(datetime ,CONVERT(nvarchar(10),CONVERT(int,left(@minday,3))+1911)+right(left(@minday,6),2)+right(@minday,2)) ),12 )+0890000),7),5),2)+'/'
				+right(right('0'+CONVERT (nvarchar(7),CONVERT (VARCHAR(7),dateadd(d,7,CONVERT(datetime ,CONVERT(nvarchar(10),CONVERT(int,left(@minday,3))+1911)+right(left(@minday,6),2)+right(@minday,2)) ),12 )+0890000),7),2)
end

--每週應排程
declare @tmpa table(
	gno nvarchar(2),
	weeks int,
	idno int identity(1,1),
	bday nvarchar(50),
	eday nvarchar(50),
	productno nvarchar(50),
	products nvarchar(50),
	ordemount float,
	planmount float,
	stkmount float,
	intmount float,
	purmount float,
	ordenos nvarchar(MAX),
	availmount float,
	ordenoa nvarchar(50),
	ordenoq nvarchar(20),
	omount float, 
	oc1 float, 
	onotv float, 
	odate nvarchar(10)
)

declare @weeks int

declare cursor_table cursor for 
select week,bweek,eweek from @tmp order by idno
open cursor_table 
fetch next from cursor_table 
into @weeks,@minday,@maxday
while(@@FETCH_STATUS <> -1) 
begin 
	insert into @tmpa
	select '0',@weeks,@minday,@maxday,a.productno,MAX(a.product)product
	,SUM(a.mount-a.c1)-isnull((select SUM(c.mount-c.c1) from view_ordes[1] c left join view_orde[1] d on c.noa=d.noa where (c.datea between @minday and @maxday) and d.stype='4' and c.productno=a.productno and c.enda!='1'),0) ordemount
	,isnull((select SUM(c.mount-c.c1) from view_ordes[1] c left join view_orde[1] d on c.noa=d.noa where (c.datea between @minday and @maxday) and d.stype='4' and c.productno=a.productno and c.enda!='1'),0) planmount
	,isnull((select SUM(mount) from stkucc[1] (@minday,'','') where productno=a.productno),0) stkmount
	,isnull((select SUM(mount-inmount) from view_work[1] where productno=a.productno),0) inmount
	,isnull((select sum(mount-c1) from view_ordcs[1] where productno=a.productno),0) purmount
	--,MAX(ucastation.pretime)pretime,MAX(ucastation.ucahours)ucahours,MAX(ucastation.stationgen)stationgen,MAX(ucastation.stationhours)stationhours
	,(select e.noa+'-'+e.no2+',' from view_ordes[1] e left join view_orde[1] f on e.noa=f.noa where e.enda!='1' and e.productno=a.productno and (e.datea between @minday and @maxday)  and e.productno in (select noa from uca)  FOR XML PATH('')) ordeno
	,0,'','','','','',''
	from view_ordes[1] a left join view_orde[1] b on a.noa=b.noa
	--left join (select a.noa ucapno,a.hours ucahours,a.pretime,b.hours stationhours,b.gen stationgen from uca a left join station b on a.stationno=b.noa)ucastation on a.productno=ucastation.ucapno
	where a.enda!='1' 
	and (a.datea between @minday and @maxday)
	and a.productno in (select noa from uca) 
	--and charindex(a.noa+'-'+a.no2,(select ordeno+',' from workgs[1] FOR XML PATH('')))=0 
	group by productno
	
	if((select COUNT(*) from @tmpa where bday=@minday)=0)
	begin
		insert into @tmpa(gno,weeks,bday,eday)
		select '0',@weeks,@minday,@maxday
	end
	
	if(len(@isordes)>0)
	begin
		insert into @tmpa(gno,bday,eday,productno,ordenoa,ordenoq,omount,oc1,onotv,odate)
		select '2',@minday,@maxday,productno,noa,no2,mount,c1,notv,datea
		from view_ordes[1]
		where CHARINDEX(noa+'-'+no2,(select ordenos+',' from @tmpa where bday=@minday FOR XML PATH('')))>0
	end
	
	fetch next from cursor_table 
	into @weeks,@minday,@maxday
end 
close cursor_table 
deallocate cursor_table 

update @tmpa
set ordenos=LEFT(ordenos,len(ordenos)-1)
,availmount=-1*(ordemount+planmount-stkmount-intmount-purmount)

if(len(@isordes)>0)
begin
	insert into @tmpa(gno,bday,eday,productno)
	select '1',bday,eday,productno from @tmpa where gno='2' group by bday,eday,productno
	insert into @tmpa(gno,bday,eday,productno)
	select '3',bday,eday,productno from @tmpa where gno='2' group by bday,eday,productno
end

select gno,left(bday,6) mons,weeks,bday,eday,productno,products
,reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,ordemount),1)),4,12)) ordemount 
,reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,planmount),1)),4,12)) planmount 
,reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,stkmount),1)),4,12)) stkmount 
,reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,intmount),1)),4,12)) intmount 
,reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,purmount),1)),4,12)) purmount 
,reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,availmount),1)),4,12)) avaimount 
,ordenos,ordenoa,ordenoq
,reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,omount),1)),4,12)) omount 
,reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,oc1),1)),4,12)) oc1
,reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,onotv),1)),4,12)) onotv
,odate from @tmpa
order by bday,productno,gno
;

