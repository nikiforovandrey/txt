z_cugp1:--z_cugp1
declare @t_bstation nvarchar(50)
declare @t_estation nvarchar(50)
declare @t_bprocess nvarchar(50)
declare @t_eprocess nvarchar(50)
declare @t_edate nvarchar(50)
declare @t_orde nvarchar(50)

set @t_bstation = case when '#non' = [3] then '' else  [3] end
set @t_estation = case when '#non' = [4] then CHAR(255) else  [4] end
set @t_bprocess = case when '#non' = [5] then '' else  [5] end
set @t_eprocess = case when '#non' = [6] then CHAR(255) else  [6] end
set @t_edate = case when '#non' = [7] then '999/99/99' else  [7] end
set @t_orde = case when '#non' = [8] then '' else  [8] end
---------------------------------------------------------------------------------------------------------------------------------
declare @tmp table(
	gno  nvarchar(1),
	sidno int identity(1,1),
	idno nvarchar(50),
	workno nvarchar(50),
	processno nvarchar(50),
	processs nvarchar(50),
	stationno nvarchar(50),
	stations nvarchar(50),
	productno nvarchar(50),
	products nvarchar(90),
	mount float,
	hours float,
	thours float,
	days float,
	workdate nvarchar(50),
	enddate nvarchar(50),
	datea nvarchar(50),
	ghours float ,
	gens float 
)

--插入已排程的製令且未完工
insert into @tmp
select '0',a.noq,a.workno,a.processno,a.process,b.stationno,b.station,a.productno,a.product,a.mount,a.hours,'',a.days,a.cuadate,a.uindate,a.uindate,c.hours,c.gen
from cugs[1] a left join work[1] b on a.workno=b.noa  left join station c on b.stationno=c.noa
where b.enda!='1' and (b.stationno between @t_bstation and @t_estation)
order by a.noa,a.noq

--插入未排程的製令
insert into @tmp
select '2','',a.noa,a.processno,a.process,a.stationno,a.station,a.productno,a.product,a.mount,a.hours,'',round(a.mount/(b.hours*b.gen),0),cuadate,uindate,'',b.hours,b.gen
from view_work[1] a left join station b on a.stationno=b.noa
where enda!='1' and (a.stationno between @t_bstation and @t_estation) and a.noa not in (select workno from cugs[1])
and a.stationno!='' and (a.processno between @t_bprocess and @t_eprocess)
order by a.stationno,case when a.cuadate='' then '999/99/99' else a.cuadate end,case when a.uindate='' then '999/99/99' else a.uindate end,a.processno,a.noa desc,a.hours--讓要最先做的製程放在最前面

declare @t_stationno nvarchar(50)
declare @stationno nvarchar(50)
declare @sidno nvarchar(50)

--今天日期
declare @now_date nvarchar(30)
set @now_date=CONVERT (VARCHAR(7), GETDATE(),12 )+0890000
set @now_date=left(@now_date,3)+'/'+substring(@now_date,4,2)+'/'+right(@now_date,2)

insert into @tmp (gno,stationno,stations,datea,ghours,gens)
select '1',stationno,MAX(stations),@now_date,MAX(ghours),MAX(gens) from @tmp group by stationno
insert into @tmp (gno,stationno,stations)
select '3',stationno,MAX(stations) from @tmp group by stationno

update a
set datea=(select MAX(datea) from @tmp where stationno=a.stationno)
from @tmp a where gno='0' or gno='1'

--處理未排程的開工日與完工日
declare @gno nvarchar(30) 
declare @ghours float
declare @gens float
declare @t_ghours float
declare @t_gens float
declare @bgens float --剩餘產能
declare @s_bgens float --指定剩餘產能
declare @t_enddate nvarchar(30) --排程的完工時間
declare @t_workdate nvarchar(30) --排程的開工時間
declare @s_enddate nvarchar(30) --指定排程的完工時間
declare @s_workdate nvarchar(30) --指定排程的開工時間
declare @workdate nvarchar(30)
declare @enddate nvarchar(30)
declare @mount float
declare @t_weekday int--星期
declare @workno nvarchar(30)

--暫存產能
declare @tmpa table(
	sidno int,
	workdate nvarchar(50), 
	enddate nvarchar(50),
	bgens float,
	workno nvarchar(50)
) 

declare cursor_table cursor for 
select stationno,gno,ghours,gens,mount,workdate,enddate,sidno,workno from @tmp where gno='1' or gno='2' order by stationno,gno,idno
open cursor_table 
fetch next from cursor_table 
into @stationno,@gno,@ghours,@gens,@mount,@workdate,@enddate,@sidno,@workno
while(@@FETCH_STATUS <> -1) 
begin 
	if(@gno='1') 
	begin 
		set @t_ghours=@ghours
		set @t_gens=@gens
		
		if((select COUNT(*) from @tmp where gno='0' and stationno=@stationno)=0 --沒有排程
			or (select  top 1 enddate from @tmp where gno='0' and stationno=@stationno order by sidno desc)<@now_date --今天沒有排程
		)
		begin
			set @bgens=@t_ghours*@t_gens
			set @t_enddate=@now_date
		end
		else
		begin
			--總產能-平均產能
			set @bgens=round((@t_ghours*@t_gens)-(select SUM(mount) from @tmp where gno='0' and stationno=@stationno)/(@t_ghours*@t_gens),0)
			set @t_enddate=(select top 1 enddate from @tmp where gno='0' and stationno=@stationno order by sidno desc)
		end
	end 
	else
	begin
		--有指定時間開工且日期大於可開工時間 且不在指定開工日內,且開工日小於截止運算日
		if(@workdate!='' and @workdate>@t_enddate and((select count(*) from @tmpa where @workdate between workdate and enddate)=0) and @t_enddate<@t_edate)
		begin
			set @s_workdate=@workdate
			set @s_enddate=@workdate
			set @s_bgens=@t_ghours*@t_gens-@mount
			
			while (@s_bgens < 0)
			begin
				--往後一天
				set @s_enddate=
				left(right('0'+CONVERT (nvarchar(7),CONVERT (VARCHAR(7),dateadd(d,1,CONVERT(datetime ,CONVERT(nvarchar(10),CONVERT(int,left(@s_enddate,3))+1911)+right(left(@s_enddate,6),2)+right(@s_enddate,2)) ),12 )+0890000),7),3)+'/'
				+right(left(right('0'+CONVERT (nvarchar(7),CONVERT (VARCHAR(7),dateadd(d,1,CONVERT(datetime ,CONVERT(nvarchar(10),CONVERT(int,left(@s_enddate,3))+1911)+right(left(@s_enddate,6),2)+right(@s_enddate,2)) ),12 )+0890000),7),5),2)+'/'
				+right(right('0'+CONVERT (nvarchar(7),CONVERT (VARCHAR(7),dateadd(d,1,CONVERT(datetime ,CONVERT(nvarchar(10),CONVERT(int,left(@s_enddate,3))+1911)+right(left(@s_enddate,6),2)+right(@s_enddate,2)) ),12 )+0890000),7),2)
				
				set @t_weekday=DATEPART(WEEKDAY, cast(cast(left(@s_enddate,3)as int)+1911 as NVARCHAR(10))+right(left(@s_enddate,6),2)+right(@s_enddate,2))-1
				
				--遇到假日和周休在往後一天
				while(@s_enddate in (select noa from holiday)or @t_weekday=0 or (@t_weekday=6 and 1=[2]))
				begin
					set @s_enddate=
					left(right('0'+CONVERT (nvarchar(7),CONVERT (VARCHAR(7),dateadd(d,1,CONVERT(datetime ,CONVERT(nvarchar(10),CONVERT(int,left(@s_enddate,3))+1911)+right(left(@s_enddate,6),2)+right(@s_enddate,2)) ),12 )+0890000),7),3)+'/'
					+right(left(right('0'+CONVERT (nvarchar(7),CONVERT (VARCHAR(7),dateadd(d,1,CONVERT(datetime ,CONVERT(nvarchar(10),CONVERT(int,left(@s_enddate,3))+1911)+right(left(@s_enddate,6),2)+right(@s_enddate,2)) ),12 )+0890000),7),5),2)+'/'
					+right(right('0'+CONVERT (nvarchar(7),CONVERT (VARCHAR(7),dateadd(d,1,CONVERT(datetime ,CONVERT(nvarchar(10),CONVERT(int,left(@s_enddate,3))+1911)+right(left(@s_enddate,6),2)+right(@s_enddate,2)) ),12 )+0890000),7),2)
					
					set @t_weekday=DATEPART(WEEKDAY, cast(cast(left(@s_enddate,3)as int)+1911 as NVARCHAR(10))+right(left(@s_enddate,6),2)+right(@s_enddate,2))-1
				end
				
				set @s_bgens=@s_bgens+(@t_ghours*@t_gens)--加一天產能
				
			end	
			
			insert into @tmpa
			select @sidno,@s_workdate,@s_enddate,@s_bgens,@workno
			
			update @tmp
			set workdate=@s_workdate+(case when @workdate!='' then '<BR>('+@workdate+')' else '' end),enddate=@s_enddate
			where sidno=@sidno
		end
		--處理階層關係
		else if(left(@workno,10) in (select left(workno,10) from @tmpa))
		begin
			set @s_workdate=(select top 1 enddate from @tmpa where left(@workno,10)=left(workno,10) order by sidno desc)
			set @s_enddate=(select top 1 enddate from @tmpa where left(@workno,10)=left(workno,10) order by sidno desc)
			set @s_bgens=(select top 1 bgens from @tmpa where left(@workno,10)=left(workno,10) order by sidno desc)-@mount
			
			--判斷工作日是否大於運算截止日
			if(@s_workdate>@t_edate)
			begin
				delete @tmp
				where sidno=@sidno
				fetch next from cursor_table 
				into @stationno,@gno,@ghours,@gens,@mount,@workdate,@enddate,@sidno,@workno
				CONTINUE
			end
			
			while (@s_bgens < 0)
			begin
				--往後一天
				set @s_enddate=
				left(right('0'+CONVERT (nvarchar(7),CONVERT (VARCHAR(7),dateadd(d,1,CONVERT(datetime ,CONVERT(nvarchar(10),CONVERT(int,left(@s_enddate,3))+1911)+right(left(@s_enddate,6),2)+right(@s_enddate,2)) ),12 )+0890000),7),3)+'/'
				+right(left(right('0'+CONVERT (nvarchar(7),CONVERT (VARCHAR(7),dateadd(d,1,CONVERT(datetime ,CONVERT(nvarchar(10),CONVERT(int,left(@s_enddate,3))+1911)+right(left(@s_enddate,6),2)+right(@s_enddate,2)) ),12 )+0890000),7),5),2)+'/'
				+right(right('0'+CONVERT (nvarchar(7),CONVERT (VARCHAR(7),dateadd(d,1,CONVERT(datetime ,CONVERT(nvarchar(10),CONVERT(int,left(@s_enddate,3))+1911)+right(left(@s_enddate,6),2)+right(@s_enddate,2)) ),12 )+0890000),7),2)
				
				set @t_weekday=DATEPART(WEEKDAY, cast(cast(left(@s_enddate,3)as int)+1911 as NVARCHAR(10))+right(left(@s_enddate,6),2)+right(@s_enddate,2))-1
				
				--遇到假日和周休在往後一天
				while(@s_enddate in (select noa from holiday)or @t_weekday=0 or (@t_weekday=6 and 1=[2]))
				begin
					set @s_enddate=
					left(right('0'+CONVERT (nvarchar(7),CONVERT (VARCHAR(7),dateadd(d,1,CONVERT(datetime ,CONVERT(nvarchar(10),CONVERT(int,left(@s_enddate,3))+1911)+right(left(@s_enddate,6),2)+right(@s_enddate,2)) ),12 )+0890000),7),3)+'/'
					+right(left(right('0'+CONVERT (nvarchar(7),CONVERT (VARCHAR(7),dateadd(d,1,CONVERT(datetime ,CONVERT(nvarchar(10),CONVERT(int,left(@s_enddate,3))+1911)+right(left(@s_enddate,6),2)+right(@s_enddate,2)) ),12 )+0890000),7),5),2)+'/'
					+right(right('0'+CONVERT (nvarchar(7),CONVERT (VARCHAR(7),dateadd(d,1,CONVERT(datetime ,CONVERT(nvarchar(10),CONVERT(int,left(@s_enddate,3))+1911)+right(left(@s_enddate,6),2)+right(@s_enddate,2)) ),12 )+0890000),7),2)
					
					set @t_weekday=DATEPART(WEEKDAY, cast(cast(left(@s_enddate,3)as int)+1911 as NVARCHAR(10))+right(left(@s_enddate,6),2)+right(@s_enddate,2))-1
				end
				
				set @s_bgens=@s_bgens+(@t_ghours*@t_gens)--加一天產能
				
			end	
			
			insert into @tmpa
			select @sidno,@s_workdate,@s_enddate,@s_bgens,@workno
			
			update @tmp
			set workdate=@s_workdate+(case when @workdate!='' then '<BR>('+@workdate+')' else '' end),enddate=@s_enddate
			where sidno=@sidno
		end
		else
		begin
			set @t_workdate=@t_enddate
			set @bgens=@bgens-@mount
			
			--判斷工作日是否大於運算截止日
			if(@t_workdate>@t_edate)
			begin
				delete @tmp
				where sidno=@sidno
				fetch next from cursor_table 
				into @stationno,@gno,@ghours,@gens,@mount,@workdate,@enddate,@sidno,@workno
				CONTINUE
			end
			
			while (@bgens < 0)
			begin
				--往後一天
				set @t_enddate=
				left(right('0'+CONVERT (nvarchar(7),CONVERT (VARCHAR(7),dateadd(d,1,CONVERT(datetime ,CONVERT(nvarchar(10),CONVERT(int,left(@t_enddate,3))+1911)+right(left(@t_enddate,6),2)+right(@t_enddate,2)) ),12 )+0890000),7),3)+'/'
				+right(left(right('0'+CONVERT (nvarchar(7),CONVERT (VARCHAR(7),dateadd(d,1,CONVERT(datetime ,CONVERT(nvarchar(10),CONVERT(int,left(@t_enddate,3))+1911)+right(left(@t_enddate,6),2)+right(@t_enddate,2)) ),12 )+0890000),7),5),2)+'/'
				+right(right('0'+CONVERT (nvarchar(7),CONVERT (VARCHAR(7),dateadd(d,1,CONVERT(datetime ,CONVERT(nvarchar(10),CONVERT(int,left(@t_enddate,3))+1911)+right(left(@t_enddate,6),2)+right(@t_enddate,2)) ),12 )+0890000),7),2)
				
				set @t_weekday=DATEPART(WEEKDAY, cast(cast(left(@t_enddate,3)as int)+1911 as NVARCHAR(10))+right(left(@t_enddate,6),2)+right(@t_enddate,2))-1
				
				--遇到假日和周休在往後一天
				while(@t_enddate in (select noa from holiday)or @t_weekday=0 or (@t_weekday=6 and 1=[2]))
				begin
					set @t_enddate=
					left(right('0'+CONVERT (nvarchar(7),CONVERT (VARCHAR(7),dateadd(d,1,CONVERT(datetime ,CONVERT(nvarchar(10),CONVERT(int,left(@t_enddate,3))+1911)+right(left(@t_enddate,6),2)+right(@t_enddate,2)) ),12 )+0890000),7),3)+'/'
					+right(left(right('0'+CONVERT (nvarchar(7),CONVERT (VARCHAR(7),dateadd(d,1,CONVERT(datetime ,CONVERT(nvarchar(10),CONVERT(int,left(@t_enddate,3))+1911)+right(left(@t_enddate,6),2)+right(@t_enddate,2)) ),12 )+0890000),7),5),2)+'/'
					+right(right('0'+CONVERT (nvarchar(7),CONVERT (VARCHAR(7),dateadd(d,1,CONVERT(datetime ,CONVERT(nvarchar(10),CONVERT(int,left(@t_enddate,3))+1911)+right(left(@t_enddate,6),2)+right(@t_enddate,2)) ),12 )+0890000),7),2)
					
					set @t_weekday=DATEPART(WEEKDAY, cast(cast(left(@t_enddate,3)as int)+1911 as NVARCHAR(10))+right(left(@t_enddate,6),2)+right(@t_enddate,2))-1
				end
				
				set @bgens=@bgens+(@t_ghours*@t_gens)--加一天產能
			end	
			
			update @tmp
			set workdate=@t_workdate+(case when @workdate!='' then '<BR>('+@workdate+')' else '' end),enddate=@t_enddate
			where sidno=@sidno
			
			insert into @tmpa
			select @sidno,@t_workdate,@t_enddate,@bgens,@workno
			
		end
	end

	fetch next from cursor_table 
	into @stationno,@gno,@ghours,@gens,@mount,@workdate,@enddate,@sidno,@workno
end 
close cursor_table 
deallocate cursor_table 

declare @noq int
set @t_stationno='XXX___XXXX'
--寫入idno
declare cursor_table cursor for 
select stationno,sidno from @tmp where gno='2' order by stationno,workdate,sidno
open cursor_table 
fetch next from cursor_table 
into @stationno,@sidno
while(@@FETCH_STATUS <> -1) 
begin 
	if(@t_stationno='XXX___XXXX' or @t_stationno!=@stationno)
	begin
		set @noq=1
	end
	
	update @tmp
	set idno= right('0000'+cast(@noq as nvarchar(50)),4)
	where sidno=@sidno
	
	set @noq=@noq+1
	set @t_stationno=@stationno

	fetch next from cursor_table 
	into @stationno,@sidno
end 
close cursor_table 
deallocate cursor_table 

--刪除沒有製令的資料
delete a
from @tmp a
where a.stationno not in (select stationno from @tmp b where gno='0' or gno='2' group by stationno)

declare @thours float
declare @hours float
set @t_stationno='XXX___XXXX'

if(@t_orde='1')
begin
	--計算總工時
	declare cursor_table cursor for 
	select stationno,sidno,hours from @tmp order by stationno,gno,processno,processs,idno
	open cursor_table 
	fetch next from cursor_table 
	into @stationno,@sidno,@hours
	while(@@FETCH_STATUS <> -1) 
	begin 
		if(@t_stationno='XXX___XXXX' or @t_stationno!=@stationno)
		begin
			set @thours=0
		end
		set @thours=@thours+isnull(@hours,0)
		
		update @tmp
		set thours=@thours
		where sidno=@sidno
		
		set @t_stationno=@stationno
		
		fetch next from cursor_table 
		into @stationno,@sidno,@hours
	end 
	close cursor_table 
	deallocate cursor_table 

	select gno,idno,workno,processno,processs,stationno,stations,productno,products
	,reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,mount),1)),0,15)) mount 
	,reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,hours),1)),0,15)) hours 
	,reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,thours),1)),0,15)) thours 
	,reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,days),1)),0,15)) days 
	,workdate,enddate,datea
	,reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,ghours),1)),0,15)) ghours 
	,reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,gens),1)),0,15)) gens 
	from @tmp
	--where processno between @t_bprocess and @t_eprocess
	order by stationno,gno,processno,processs,idno
end

if(@t_orde='2')
begin
	--計算總工時
	declare cursor_table cursor for 
	select stationno,sidno,hours from @tmp order by stationno,gno,idno
	open cursor_table 
	fetch next from cursor_table 
	into @stationno,@sidno,@hours
	while(@@FETCH_STATUS <> -1) 
	begin 
		if(@t_stationno='XXX___XXXX' or @t_stationno!=@stationno)
		begin
			set @thours=0
		end
		set @thours=@thours+isnull(@hours,0)
		
		update @tmp
		set thours=@thours
		where sidno=@sidno
		
		set @t_stationno=@stationno
		
		fetch next from cursor_table 
		into @stationno,@sidno,@hours
	end 
	close cursor_table 
	deallocate cursor_table 
	
	select gno,idno,workno,processno,processs,stationno,stations,productno,products
	,reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,mount),1)),0,15)) mount 
	,reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,hours),1)),0,15)) hours 
	,reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,thours),1)),0,15)) thours 
	,reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,days),1)),0,15)) days 
	,workdate,enddate,datea
	,reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,ghours),1)),0,15)) ghours 
	,reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,gens),1)),0,15)) gens 
	from @tmp
	--where processno between @t_bprocess and @t_eprocess
	order by stationno,gno,idno
end
;

