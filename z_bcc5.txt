z_bcc5:--z_bcc5
	declare @t_date nvarchar(10)
	declare @t_bbccno nvarchar(20)
	declare @t_ebccno nvarchar(20)
	set @t_date = case when '#non'=[1] then '' else [1] end
	set @t_bbccno = case when '#non'=[4] then '' else [4] end
	set @t_ebccno = case when '#non'=[5] then char(255) else [5] end
	--*****************************************************************************************	
declare @result table(
		gno nvarchar(1),
		typea nvarchar(20),
		bccno nvarchar(20),
		bccname nvarchar(50),
		mon nvarchar(20),
		stkmount decimal (10,2),
		tgg nvarchar (200),
		memo nvarchar (200)
)
--盤點的資料
declare @t_result table(
		typea nvarchar(20),
		bccno nvarchar(20),
		bccname nvarchar(50),
		mon nvarchar(20),
		datea nvarchar(10),
		mount decimal (14,2),
		memo nvarchar (200)
)

declare @typea nvarchar(20)
declare	@bccno nvarchar(20)
declare	@bccname nvarchar(50)
declare	@datea nvarchar(10)
declare	@mount decimal (14,2)
declare @mon nvarchar(20)
declare @memo nvarchar (200)


--計算有盤存的庫存
--取最後一筆有盤存的資料

declare bcc_table cursor for
select b.bccno from bcce a left join bcces b on a.noa=b.noa where b.bccno between @t_bbccno and @t_ebccno and a.datea < @t_date group by b.bccno
open bcc_table
fetch next from bcc_table
into @bccno
while(@@FETCH_STATUS <> -1)
begin
	insert into @t_result
	select top 1 c.typea,b.bccno,b.bccname,c.mon,a.datea,b.mount,c.memo
	from bcce a left join bcces b on a.noa=b.noa right join bcc c on b.bccno=c.noa
	where b.bccno =@bccno and a.datea < @t_date
	order by a.datea desc
	fetch next from bcc_table
	into @bccno

end
close bcc_table
deallocate bcc_table


--計算盤存到資料之前的入領料
declare bcc_table cursor for
select bccno,bccname,datea,mount,typea,mon,memo from @t_result
open bcc_table
fetch next from bcc_table
into @bccno,@bccname,@datea,@mount,@typea,@mon,@memo
while(@@FETCH_STATUS <> -1)
begin

	set @mount=@mount
		--入料
		+isnull((select sum(b.mount) mount
		from bccin a left join bccins b on a.noa=b.noa
		where b.bccno=@bccno and  a.datea between @datea and @t_date
		group by b.bccno),0)
		--領料&繳回
		-isnull((select sum(b.mount-b.bkbcc) mount1
		from bccout a left join bccouts b on a.noa=b.noa
		where b.bccno=@bccno and  a.datea between @datea and @t_date
		group by b.bccno),0)
	--存入有盤存的庫存
	insert into @result
	select '0',@typea,@bccno,@bccname,@mon,@mount,'',@memo
	fetch next from bcc_table
	into @bccno,@bccname,@datea,@mount,@typea,@mon,@memo

end
close bcc_table
deallocate bcc_table


--計算沒有盤存的庫存

declare bcc_table cursor for
select noa,product,begindate,beginmount,typea,mon,memo from bcc where noa not in (select c.noa bccno from bcce a left join bcces b on a.noa=b.noa right join bcc c on c.noa=b.bccno where b.bccno between @t_bbccno and @t_ebccno and a.datea < @t_date)
open bcc_table
fetch next from bcc_table
into @bccno,@bccname,@datea,@mount,@typea,@mon,@memo
while(@@FETCH_STATUS <> -1)
begin

	set @mount=@mount
		--入料
		+isnull((select sum(b.mount) mount
		from bccin a left join bccins b on a.noa=b.noa
		where b.bccno=@bccno and  a.datea <= @t_date
		group by b.bccno),0)
		--領料&繳回
		-isnull((select sum(b.mount-b.bkbcc) mount1
		from bccout a left join bccouts b on a.noa=b.noa
		where b.bccno=@bccno and  a.datea <= @t_date
		group by b.bccno),0)
	--存入沒有盤存的庫存
	insert into @result
	select '0',@typea,@bccno,@bccname,@mon,@mount,'',@memo

	fetch next from bcc_table
	into @bccno,@bccname,@datea,@mount,@typea,@mon,@memo

end
close bcc_table
deallocate bcc_table

--插入供應商

declare @t_tgg nvarchar (200)

	declare bcc_table cursor for
	select bccno from @result
	open bcc_table
	fetch next from bcc_table
	into @bccno
	while(@@FETCH_STATUS <> -1)
	begin
		
	set @t_tgg=
		(select LEFT(tgg,len(tgg)-1)tgg
		from(
			select bccno,(select tgg+'/' from bccin left join bccins on bccin.noa=bccins.noa where bccins.bccno=T1.bccno group by tgg FOR XML PATH(''))tgg
			from(select a.noa bccno
				from bcc a left join bccins b on a.noa=b.bccno left join bccin c on b.noa=c.noa
				group by a.noa)T1
			)T
		where bccno=@bccno
		)
		
		update @result
		set tgg=@t_tgg
		where current of bcc_table	
		
		
		fetch next from bcc_table
		into @bccno
	end
	close bcc_table
	deallocate bcc_table
	
	select * from @result order by typea,bccno;
	
	--**********************************************************************************************

z_bcc5b:--z_bcc5b
	declare @t_date nvarchar(10)
	declare @t_bbccno nvarchar(20)
	declare @t_ebccno nvarchar(20)
	set @t_date = case when '#non'=[1] then '' else [1] end
	set @t_bbccno = case when '#non'=[4] then '' else [4] end
	set @t_ebccno = case when '#non'=[5] then char(255) else [5] end
	--*****************************************************************************************	
declare @result table(
		gno nvarchar(1),
		typea nvarchar(20),
		bccno nvarchar(20),
		bccname nvarchar(50),
		stkmount decimal (14,2),
		avgprice decimal (10,2),
		total decimal (14,2),
		tgg nvarchar (200)
)
--盤點的資料
declare @t_result table(
		typea nvarchar(20),
		bccno nvarchar(20),
		bccname nvarchar(50),
		datea nvarchar(10),
		mount decimal (14,2),
		total decimal (14,2)
)

declare @typea nvarchar(20)
declare	@bccno nvarchar(20)
declare	@bccname nvarchar(50)
declare	@datea nvarchar(10)
declare	@mount decimal (14,2)
declare @total decimal (14,2)



--計算有盤存的庫存
--取最後一筆有盤存的資料

declare bcc_table cursor for
select b.bccno from bcce a left join bcces b on a.noa=b.noa where b.bccno between @t_bbccno and @t_ebccno and a.datea < @t_date group by b.bccno
open bcc_table
fetch next from bcc_table
into @bccno
while(@@FETCH_STATUS <> -1)
begin
	insert into @t_result
	select top 1 c.typea,b.bccno,b.bccname,a.datea,b.mount,b.total
	from bcce a left join bcces b on a.noa=b.noa right join bcc c on b.bccno=c.noa
	where b.bccno =@bccno and a.datea < @t_date
	order by a.datea desc
	fetch next from bcc_table
	into @bccno

end
close bcc_table
deallocate bcc_table


--計算盤存到資料之前的入領料
declare bcc_table cursor for
select bccno,bccname,datea,mount,typea,total from @t_result
open bcc_table
fetch next from bcc_table
into @bccno,@bccname,@datea,@mount,@typea,@total
while(@@FETCH_STATUS <> -1)
begin
	--計算價錢
	set @total=@total
		--入料
		+isnull((select sum(b.total) total
		from bccin a left join bccins b on a.noa=b.noa
		where b.bccno=@bccno and  a.datea between @datea and @t_date
		group by b.bccno),0)
		
	--計算庫存
	set @mount=@mount
		--入料
		+isnull((select sum(b.mount) mount
		from bccin a left join bccins b on a.noa=b.noa
		where b.bccno=@bccno and  a.datea between @datea and @t_date
		group by b.bccno),0)
		--領料&繳回
		-isnull((select sum(b.mount-b.bkbcc) mount1
		from bccout a left join bccouts b on a.noa=b.noa
		where b.bccno=@bccno and  a.datea between @datea and @t_date
		group by b.bccno),0)
	--存入有盤存的庫存
	insert into @result
	select '0',@typea,@bccno,@bccname,@mount,@total/nullif(@mount,0),@total,''
	fetch next from bcc_table
	into @bccno,@bccname,@datea,@mount,@typea,@total
end
close bcc_table
deallocate bcc_table


--計算沒有盤存的庫存

declare bcc_table cursor for
select noa,product,begindate,beginmount,typea,beginmoney from bcc where noa not in (select c.noa bccno from bcce a left join bcces b on a.noa=b.noa right join bcc c on c.noa=b.bccno where b.bccno between @t_bbccno and @t_ebccno and a.datea < @t_date)
open bcc_table
fetch next from bcc_table
into @bccno,@bccname,@datea,@mount,@typea,@total
while(@@FETCH_STATUS <> -1)
begin
	--計算價錢
	set @total=@total
		--入料
		+isnull((select sum(b.total) total
		from bccin a left join bccins b on a.noa=b.noa
		where b.bccno=@bccno and  a.datea <= @t_date
		group by b.bccno),0)

	--計算庫存
	set @mount=@mount
		--入料
		+isnull((select sum(b.mount) mount
		from bccin a left join bccins b on a.noa=b.noa
		where b.bccno=@bccno and  a.datea <= @t_date
		group by b.bccno),0)
		--領料&繳回
		-isnull((select sum(b.mount-b.bkbcc) mount1
		from bccout a left join bccouts b on a.noa=b.noa
		where b.bccno=@bccno and  a.datea <= @t_date
		group by b.bccno),0)
	--存入沒有盤存的庫存
	insert into @result
	select '0',@typea,@bccno,@bccname,@mount,@total/nullif(@mount,0),@total,''

	fetch next from bcc_table
	into @bccno,@bccname,@datea,@mount,@typea,@total

end
close bcc_table
deallocate bcc_table

--插入供應商

declare @t_tgg nvarchar (200)

	declare bcc_table cursor for
	select bccno from @result
	open bcc_table
	fetch next from bcc_table
	into @bccno
	while(@@FETCH_STATUS <> -1)
	begin
		
	set @t_tgg=
		(select LEFT(tgg,len(tgg)-1)tgg
		from(
			select bccno,(select tgg+'/' from bccin left join bccins on bccin.noa=bccins.noa where bccins.bccno=T1.bccno group by tgg FOR XML PATH(''))tgg
			from(select a.noa bccno
				from bcc a left join bccins b on a.noa=b.bccno left join bccin c on b.noa=c.noa
				group by a.noa)T1
			)T
		where bccno=@bccno
		)
		
		update @result
		set tgg=@t_tgg
		where current of bcc_table	
		
		
		fetch next from bcc_table
		into @bccno
	end
	close bcc_table
	deallocate bcc_table

	select gno,typea,bccno,bccname,stkmount,tgg,
	reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,avgprice),1)),4,12)) avgprice,
	reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,total),1)),4,12)) total
	from @result order by typea,bccno;
--*********************************************************************************************
z_bcc5c:--z_bcc5c
	declare @t_bmon nvarchar(10)
	declare @t_emon nvarchar(10)
	declare @t_bbccno nvarchar(20)
	declare @t_ebccno nvarchar(20)
	set @t_bmon = case when '#non'=[2] then '' else [2] end
	set @t_emon = case when '#non'=[3] then '' else [3] end
	set @t_bbccno = case when '#non'=[4] then '' else [4] end
	set @t_ebccno = case when '#non'=[5] then char(255) else [5] end
	--*****************************************************************************************	
declare @tmp table( 
gno nvarchar(1), 
datea nvarchar(10), 
bccno nvarchar(20), 
bccname nvarchar(50), 
price float, 
inmount decimal (14,2), 
outmount decimal (14,2), 
stkmount decimal (14,2), 
usename nvarchar(20), 
memo nvarchar (200) 
) 
--盤點的資料 
declare @t_result table( 
bccno nvarchar(20), 
bccname nvarchar(50), 
datea nvarchar(10), 
mount decimal (14,2), 
total decimal (14,2) 
) 

declare	@bccno nvarchar(20) 
declare	@bccname nvarchar(50) 
declare	@datea nvarchar(10) 
declare	@mount decimal (14,2) 
declare @total decimal (14,2) 
declare	@t_mount decimal (14,2) 
declare @t_total decimal (14,2) 
set @t_total=0 
set @t_mount=0 

--計算有盤存的庫存 
--取最後一筆有盤存的資料 

declare bcc_table cursor for 
select b.bccno from bcce a left join bcces b on a.noa=b.noa where b.bccno between @t_bbccno and @t_ebccno and a.datea < @t_bmon+'/01' group by b.bccno 
open bcc_table 
fetch next from bcc_table 
into @bccno 
while(@@FETCH_STATUS <> -1) 
begin 
insert into @t_result 
select top 1 b.bccno,b.bccname,a.datea,b.mount,b.total 
from bcce a left join bcces b on a.noa=b.noa 
where b.bccno =@bccno and a.datea < @t_bmon+'/01' 
order by a.datea desc 
fetch next from bcc_table 
into @bccno 

end 
close bcc_table 
deallocate bcc_table 

--計算盤存到資料之前的入領料 
declare bcc_table cursor for 
select bccno,bccname,datea,mount,total from @t_result 
open bcc_table 
fetch next from bcc_table 
into @bccno,@bccname,@datea,@mount,@total 
while(@@FETCH_STATUS <> -1) 
begin 
--計算價錢 
set @t_total=@total+ 
--入料 
isnull((select sum(b.total) total 
from bccin a left join bccins b on a.noa=b.noa 
where b.bccno=@bccno and a.datea > @datea and a.datea< @t_bmon+'/01' 
group by b.bccno),0) 


--計算庫存 
set @t_mount=@mount+ 
--入料 
isnull((select sum(b.mount) mount 
from bccin a left join bccins b on a.noa=b.noa 
where b.bccno=@bccno and a.datea > @datea and a.datea< @t_bmon+'/01' 
group by b.bccno),0) 
--領料&繳回 
-isnull((select sum(b.mount-b.bkbcc) mount1 
from bccout a left join bccouts b on a.noa=b.noa 
where b.bccno=@bccno and a.datea > @datea and a.datea< @t_bmon+'/01' 
group by b.bccno),0) 
--存入有盤存的庫存 
insert into @tmp 
select '0',' 庫存',@bccno,@bccname,round(@total/nullif(@mount,0),0),0,0,@mount,'','' 
set @t_total=0 
set @t_mount=0 
fetch next from bcc_table 
into @bccno,@bccname,@datea,@mount,@total 
end 
close bcc_table 
deallocate bcc_table 

--計算沒有盤存的庫存 

declare bcc_table cursor for 
select noa,product,begindate,beginmount,beginmoney from bcc where noa not in (select c.noa bccno from bcce a left join bcces b on a.noa=b.noa right join bcc c on c.noa=b.bccno where b.bccno between @t_bbccno and @t_ebccno and a.datea < @t_bmon+'/01') 
open bcc_table 
fetch next from bcc_table 
into @bccno,@bccname,@datea,@mount,@total 
while(@@FETCH_STATUS <> -1) 
begin 
--計算價錢 
set @t_total=@total+ 
--入料 
isnull((select sum(b.total) total 
from bccin a left join bccins b on a.noa=b.noa 
where b.bccno=@bccno and a.datea < @t_bmon+'/01' 
group by b.bccno),0) 

--計算庫存 
set @t_mount=@mount+ 
--入料 
isnull((select sum(b.mount) mount 
from bccin a left join bccins b on a.noa=b.noa 
where b.bccno=@bccno and a.datea < @t_bmon+'/01' 
group by b.bccno),0) 
--領料&繳回 
-isnull((select sum(b.mount-b.bkbcc) mount1 
from bccout a left join bccouts b on a.noa=b.noa 
where b.bccno=@bccno and a.datea < @t_bmon+'/01' 
group by b.bccno),0) 
--存入沒有盤存的庫存 
insert into @tmp 
select '0',' 庫存',@bccno,@bccname,round(@total/nullif(@mount,0),0),0,0,@mount,'','' 

set @t_total=0 
set @t_mount=0 

fetch next from bcc_table 
into @bccno,@bccname,@datea,@mount,@total 

end 
close bcc_table 
deallocate bcc_table 

--插入進出貨明細 
insert into @tmp 
select '0',a.datea,b.bccno,b.bccname,b.price,b.mount,null,null,null,b.memo 
from bccin a left join bccins b on a.noa=b.noa 
where a.datea between @t_bmon+'/01' and @t_emon+'/31' 

insert into @tmp 
select '0',a.datea,b.bccno,b.bccname,null,null,b.mount,null,b.sname,b.memo 
from bccout a left join bccouts b on a.noa=b.noa 
where a.datea between @t_bmon+'/01' and @t_emon+'/31' 

declare @result table( 
gno nvarchar(1), 
datea nvarchar(10), 
bccno nvarchar(20), 
bccname nvarchar(50), 
price float, 
inmount decimal (14,2), 
outmount decimal (14,2), 
stkmount decimal (14,2), 
usename nvarchar(20), 
memo nvarchar (200) 
) 
insert into @result 
select * from @tmp order by bccno,datea 

--更新庫存量 

declare @inmount decimal (14,2) 
declare @outmount decimal (14,2) 
declare @stkmount decimal (14,2) 
declare @t_stkmount decimal (14,2) 

set @t_stkmount=0 

declare bcc_table cursor for 
select datea,bccno,inmount,outmount,stkmount from @result 
open bcc_table 
fetch next from bcc_table 
into @datea,@bccno,@inmount,@outmount,@stkmount 
while(@@FETCH_STATUS <> -1) 
begin 
if(@datea=' 庫存') 
begin 
set @t_stkmount=@stkmount 
end 
else 
begin 
update @result 
set stkmount=@t_stkmount+isnull(@inmount,0)-isnull(@outmount,0)	where current of bcc_table	
set @t_stkmount=@t_stkmount+isnull(@inmount,0)-isnull(@outmount,0) 
end 

fetch next from bcc_table 
into @datea,@bccno,@inmount,@outmount,@stkmount 
end 
close bcc_table 
deallocate bcc_table 

insert into @result 
select '1',null,bccno,bccname,null,null,null,null,null,null from @result group by bccno,bccname

insert into @result 
select '0',null,bccno,null,null,null,null,null,null,null from @result group by bccno
insert into @result 
select '0',null,bccno,null,null,null,null,null,null,null from @result group by bccno
update @result 
set bccname=null where datea=' 庫存'

-------------不要讓同一個資材拆成兩頁
declare @space bit	
declare @count int
declare	@t_bccno nvarchar(20)
declare	@t_bccno2 nvarchar(20)
declare	@t_bccno33 nvarchar(20)
declare	@gno nvarchar(1)
declare	@t_gno nvarchar(1)
set @space=1
set @t_bccno='XXXX'
set @t_bccno2='YYYY'


while(@space=1)
begin 
	set @count=0
	declare bcc_table cursor for 
	select gno,bccno from @result order by bccno,gno desc 
	open bcc_table 
	fetch next from bcc_table 
	into @gno,@bccno
	while(@@FETCH_STATUS <> -1) 
	begin
		set @count=@count+1
		if(@bccno!=@t_bccno)
		begin
			set @t_bccno2=@t_bccno
			set @t_bccno=@bccno
		end
		if(@count%33=0)
		begin
			set @t_bccno33=@t_bccno
		end
		if(@count%34=0 and @bccno=@t_bccno33)
		begin
			set @space=1
			insert into @result 
			select '0',null,@t_bccno2,null,null,null,null,null,null,null
			break
		end
		set @space=0
		fetch next from bcc_table 
		into @gno,@bccno
	end 
	close bcc_table 
	deallocate bcc_table 
end --while

-------------------

select gno,datea,bccno,bccname,usename,memo,
reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,price),1)),4,12)) price,
reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,inmount),1)),4,12)) inmount,
reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,outmount),1)),4,12)) outmount,
reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,stkmount),1)),4,12)) stkmount
from @result order by bccno,gno desc;
