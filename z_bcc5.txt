z_bcc5a:--z_bcc5a
	SET QUOTED_IDENTIFIER OFF
	declare @cmd nvarchar(max)
	declare @t_bdate nvarchar(10)
	declare @t_edate nvarchar(10)
	declare @t_bbccno nvarchar(20)
	declare @t_ebccno nvarchar(20)
	declare @t_store nvarchar(max)
	declare @t_part nvarchar(max)
	set @t_bdate = case when '#non'=[1] then '' else [1] end
	set @t_edate = case when '#non'=[2] then char(255) else [2] end
	set @t_bbccno = case when '#non'=[3] then '' else [3] end
	set @t_ebccno = case when '#non'=[4] then char(255) else [4] end
	set @t_store = case when '#non'=[5] then '' else [5] end
	set @t_part = case when '#non'=[6] then '' else [6] end
	-----------------------------------------------------------------------------
	declare @string nvarchar(max)
	declare @n int
	IF OBJECT_ID('tempdb..#store')is not null
	BEGIN
		set @cmd = 'drop table #store'
		EXECUTE sp_executesql @cmd
	END
	create table #store(
		noa nvarchar(20)
	)
	set @string = @t_store
	while(1=1)
	begin
		set @n = PATINDEX('%,%',@string)
		if @n=0
		begin
			if LEN(@string)>0
			begin
				insert into #store select @string
			end
			break
		end
		insert into #store select LEFT(@string,@n-1)	
		set @string = SUBSTRING(@string,@n+1,LEN(@string)-@n)
	end
	
	IF OBJECT_ID('tempdb..#part')is not null
	BEGIN
		set @cmd = 'drop table #part'
		EXECUTE sp_executesql @cmd
	END
	create table #part(
		noa nvarchar(20)
	)
	set @string = @t_part
	while(1=1)
	begin
		set @n = PATINDEX('%,%',@string)
		if @n=0
		begin
			if LEN(@string)>0
			begin
				insert into #part select @string
			end
			break
		end
		insert into #part select LEFT(@string,@n-1)	
		set @string = SUBSTRING(@string,@n+1,LEN(@string)-@n)
	end
	-----------------------------------------------------------------------------
	declare @noa nvarchar(20)
	declare @noq nvarchar(10)
	declare @typea nvarchar(10)
	declare @storeno nvarchar(20)
	declare @bccno nvarchar(20)
	declare @datea nvarchar(20)
	declare @mount float
	declare @price float
	declare @total float
	declare @mount2 float
	
	declare @tmp table(
		gno nvarchar(3),
		typea nvarchar(10),
		datea nvarchar(20),
		noa nvarchar(20),
		noq nvarchar(10),
		storeno nvarchar(20),
		bccno nvarchar(20),	
		bccname nvarchar(40),
		mount float,
		price float,
		total float,
		mount2 float
	)
	insert into @tmp
	select '0','A',ISNULL(b.datea,''),a.noa+'盤點',a.noq,isnull(a.storeno,''),isnull(a.bccno,''),a.bccname,isnull(a.mount,0),ISNULL(a.price,0),ISNULL(a.total,0),0
	from bcces a
	left join bcce b on a.noa=b.noa
	left join #store c on a.storeno=c.noa
	where (ISNULL(a.bccno,'') between @t_bbccno and @t_ebccno)
	and (ISNULL(b.datea,'')<=@t_edate)
	insert into @tmp
	select '0','B',ISNULL(b.datea,''),a.noa+'入料',a.noq,isnull(a.storeno,''),isnull(a.bccno,''),a.bccname,isnull(a.mount,0),ISNULL(a.price,0),ISNULL(a.total,0),0
	from bccins a
	left join bccin b on a.noa=b.noa
	left join #store c on a.storeno=c.noa
	where (ISNULL(a.bccno,'') between @t_bbccno and @t_ebccno)
	and (ISNULL(b.datea,'')<=@t_edate)
	insert into @tmp
	select '0','C',ISNULL(b.datea,''),a.noa+'領料',a.noq,isnull(a.storeno,''),isnull(a.bccno,''),a.bccname,isnull(a.mount-a.bkbcc,0),null,null,0
	from bccouts a
	left join bccout b on a.noa=b.noa
	left join #store c on a.storeno=c.noa
	where (ISNULL(a.bccno,'') between @t_bbccno and @t_ebccno)
	and (ISNULL(b.datea,'')<=@t_edate)

	declare @bmount float
	
	declare cursor_table cursor for
	select storeno,bccno from @tmp group by storeno,bccno
	open cursor_table
	fetch next from cursor_table
	into @storeno,@bccno
	while(@@FETCH_STATUS <> -1)
	begin
		select @bmount=0 ,@mount2=0
	
		declare cursor_table2 cursor for
		select noa,noq,typea,datea,isnull(mount,0) from @tmp where storeno=@storeno and bccno=@bccno order by datea,typea,noa,noq
		open cursor_table2
		fetch next from cursor_table2
		into @noa,@noq,@typea,@datea,@mount
		while(@@FETCH_STATUS <> -1)
		begin
			if(@typea='A')
				set @mount2 = @mount
			else
			begin
				set @mount2 = @mount2 + case when @typea='B' then @mount else -@mount end
			end
			update @tmp set mount2=@mount2 where noa=@noa and noq=@noq
			if(@datea<@t_bdate)
			begin
				set @bmount=@mount2
			end
			fetch next from cursor_table2
			into @noa,@noq,@typea,@datea,@mount
		end
		close cursor_table2
		deallocate cursor_table2	
		insert into @tmp(gno,typea,storeno,bccno,noa,mount2)values('1','',@storeno,@bccno,'庫存量',@mount2)

		insert into @tmp(gno,typea,storeno,bccno,noa,mount2)values('0','',@storeno,@bccno,'前期存量',@bmount)

		fetch next from cursor_table
		into @storeno,@bccno
	end
	close cursor_table
	deallocate cursor_table
	
	delete @tmp where datea<@t_bdate and len(typea)>0
	select a.*
	,a.storeno sa 
	,b.store sb
	,a.bccno ba
	,c.product bb
	,reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,a.mount),1)),4,12)) mt1
	,reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,a.total),1)),4,12)) tt
	,reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,a.mount2),1)),4,12)) mt2
	from @tmp a
	left join store b on a.storeno=b.noa
	left join bcc c on c.noa=a.bccno
	order by a.storeno,a.bccno,a.gno,a.datea,a.typea,a.noa,a.noq;
	
z_bcc5b:--z_bcc5b
	SET QUOTED_IDENTIFIER OFF
	declare @cmd nvarchar(max)
	declare @t_bdate nvarchar(10)
	declare @t_edate nvarchar(10)
	declare @t_bbccno nvarchar(20)
	declare @t_ebccno nvarchar(20)
	declare @t_store nvarchar(max)
	declare @t_part nvarchar(max)
	declare @t_all nvarchar(max)
	set @t_bdate = case when '#non'=[1] then '' else [1] end
	set @t_edate = case when '#non'=[2] then char(255) else [2] end
	set @t_bbccno = case when '#non'=[3] then '' else [3] end
	set @t_ebccno = case when '#non'=[4] then char(255) else [4] end
	set @t_store = case when '#non'=[5] then '' else [5] end
	set @t_part = case when '#non'=[6] then '' else [6] end
	set @t_all = case when '#non'=[7] then '' else [7] end
	-----------------------------------------------------------------------------
	declare @string nvarchar(max)
	declare @n int
	IF OBJECT_ID('tempdb..#store')is not null
	BEGIN
		set @cmd = 'drop table #store'
		EXECUTE sp_executesql @cmd
	END
	create table #store(
		noa nvarchar(20)
	)
	set @string = @t_store
	while(1=1)
	begin
		set @n = PATINDEX('%,%',@string)
		if @n=0
		begin
			if LEN(@string)>0
			begin
				insert into #store select @string
			end
			break
		end
		insert into #store select LEFT(@string,@n-1)	
		set @string = SUBSTRING(@string,@n+1,LEN(@string)-@n)
	end
	
	IF OBJECT_ID('tempdb..#part')is not null
	BEGIN
		set @cmd = 'drop table #part'
		EXECUTE sp_executesql @cmd
	END
	create table #part(
		noa nvarchar(20)
	)
	set @string = @t_part
	while(1=1)
	begin
		set @n = PATINDEX('%,%',@string)
		if @n=0
		begin
			if LEN(@string)>0
			begin
				insert into #part select @string
			end
			break
		end
		insert into #part select LEFT(@string,@n-1)	
		set @string = SUBSTRING(@string,@n+1,LEN(@string)-@n)
	end
	-----------------------------------------------------------------------------
	declare @noa nvarchar(20)
	declare @noq nvarchar(10)
	declare @typea nvarchar(10)
	declare @storeno nvarchar(20)
	declare @bccno nvarchar(20)
	declare @datea nvarchar(20)
	declare @mount float
	declare @price float
	declare @total float
	declare @mount2 float
	
	declare @tmp table(
		gno nvarchar(3),
		typea nvarchar(10),
		datea nvarchar(20),
		noa nvarchar(20),
		noq nvarchar(10),
		storeno nvarchar(20),
		bccno nvarchar(20),	
		bccname nvarchar(40),
		mount float,
		price float,
		total float,
		mount2 float
	)
	insert into @tmp
	select '0','A',ISNULL(b.datea,''),a.noa+'盤點',a.noq,isnull(a.storeno,''),isnull(a.bccno,''),a.bccname,isnull(a.mount,0),ISNULL(a.price,0),ISNULL(a.total,0),0
	from bcces a
	left join bcce b on a.noa=b.noa
	left join #store c on a.storeno=c.noa
	where (ISNULL(a.bccno,'') between @t_bbccno and @t_ebccno)
	and (ISNULL(b.datea,'')<=@t_edate)
	insert into @tmp
	select '0','B',ISNULL(b.datea,''),a.noa+'入料',a.noq,isnull(a.storeno,''),isnull(a.bccno,''),a.bccname,isnull(a.mount,0),ISNULL(a.price,0),ISNULL(a.total,0),0
	from bccins a
	left join bccin b on a.noa=b.noa
	left join #store c on a.storeno=c.noa
	where (ISNULL(a.bccno,'') between @t_bbccno and @t_ebccno)
	and (ISNULL(b.datea,'')<=@t_edate)
	insert into @tmp
	select '0','C',ISNULL(b.datea,''),a.noa+'領料',a.noq,isnull(a.storeno,''),isnull(a.bccno,''),a.bccname,isnull(a.mount-a.bkbcc,0),null,null,0
	from bccouts a
	left join bccout b on a.noa=b.noa
	left join #store c on a.storeno=c.noa
	where (ISNULL(a.bccno,'') between @t_bbccno and @t_ebccno)
	and (ISNULL(b.datea,'')<=@t_edate)

	declare @bmount float
	
	declare cursor_table cursor for
	select storeno,bccno from @tmp group by storeno,bccno
	open cursor_table
	fetch next from cursor_table
	into @storeno,@bccno
	while(@@FETCH_STATUS <> -1)
	begin
		select @bmount=0 ,@mount2=0
	
		declare cursor_table2 cursor for
		select noa,noq,typea,datea,isnull(mount,0) from @tmp where storeno=@storeno and bccno=@bccno order by datea,typea,noa,noq
		open cursor_table2
		fetch next from cursor_table2
		into @noa,@noq,@typea,@datea,@mount
		while(@@FETCH_STATUS <> -1)
		begin
			if(@typea='A')
				set @mount2 = @mount
			else
			begin
				set @mount2 = @mount2 + case when @typea='B' then @mount else -@mount end
			end
			update @tmp set mount2=@mount2 where noa=@noa and noq=@noq
			if(@datea<@t_bdate)
			begin
				set @bmount=@mount2
			end
			fetch next from cursor_table2
			into @noa,@noq,@typea,@datea,@mount
		end
		close cursor_table2
		deallocate cursor_table2	
		insert into @tmp(gno,typea,storeno,bccno,noa,mount2)values('1','',@storeno,@bccno,'庫存量',@mount2)

		insert into @tmp(gno,typea,storeno,bccno,noa,mount2)values('0','',@storeno,@bccno,'前期存量',@bmount)

		fetch next from cursor_table
		into @storeno,@bccno
	end
	close cursor_table
	deallocate cursor_table
	
	delete @tmp where gno='0'
	update @tmp set gno='0'
	
	if(@t_all='剩餘量')
		delete @tmp where mount2=0
	if(@t_all='無存量')
		delete @tmp where mount2>0
	
	delete @tmp where datea<@t_bdate and len(typea)>0
	select a.*
	,a.storeno sa 
	,b.store sb
	,a.bccno ba
	,c.product bb
	,reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,a.mount),1)),4,12)) mt1
	,reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,a.total),1)),4,12)) tt
	,reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,a.mount2),1)),4,12)) mt2
	from @tmp a
	left join store b on a.storeno=b.noa
	left join bcc c on c.noa=a.bccno
	order by a.storeno,a.bccno,a.gno,a.datea,a.typea,a.noa,a.noq;
	
--********************************************************************************************
z_bcc5c:--z_bcc5c
	declare @t_bdate nvarchar(10)
	declare @t_edate nvarchar(10)
	declare @t_bbccno nvarchar(20)
	declare @t_ebccno nvarchar(20)
	declare @t_storeno nvarchar(max)
	set @t_bdate = case when '#non'=[1] then '' else [1] end
	set @t_edate = case when '#non'=[2] then '' else [2] end
	set @t_bbccno = case when '#non'=[3] then '' else [3] end
	set @t_ebccno = case when '#non'=[4] then char(255) else [4] end
	set @t_storeno = case when '#non'=[5] then '' else [5] end
	--*****************************************************************************************	
declare @tmp table( 
	storeno nvarchar(20),
	gno nvarchar(1), 
	datea nvarchar(10), 
	bccno nvarchar(20), 
	bccname nvarchar(50), 
	price float, 
	inmount decimal (14,2), 
	outmount decimal (14,2), 
	stkmount decimal (14,2), 
	usename nvarchar(20), 
	memo nvarchar (200) 
) 
--盤點的資料 
declare @t_result table( 
	storeno nvarchar(20),
	bccno nvarchar(20), 
	bccname nvarchar(50), 
	datea nvarchar(10), 
	mount decimal (14,2), 
	total decimal (14,2) 
) 

declare	@storeno nvarchar(20)
declare	@bccno nvarchar(20) 
declare	@bccname nvarchar(50) 
declare	@datea nvarchar(10) 
declare	@mount decimal (14,2) 
declare @total decimal (14,2) 
declare	@t_mount decimal (14,2) 
declare @t_total decimal (14,2) 
declare @t_price float
set @t_total=0 
set @t_mount=0 

--計算有盤存的庫存 
--取最後一筆有盤存的資料 

declare bcc_table cursor for 
select b.storeno,b.bccno from bcce a left join bcces b on a.noa=b.noa where b.bccno between @t_bbccno and @t_ebccno and a.datea < @t_bdate group by b.storeno,b.bccno 
open bcc_table 
fetch next from bcc_table 
into @storeno,@bccno 
while(@@FETCH_STATUS <> -1) 
begin 
insert into @t_result 
select top 1 b.storeno,b.bccno,b.bccname,a.datea,b.mount,b.total 
from bcce a left join bcces b on a.noa=b.noa 
where b.bccno =@bccno and a.datea < @t_bdate and b.storeno=@storeno
order by a.datea desc 
fetch next from bcc_table 
into @storeno,@bccno 

end 
close bcc_table 
deallocate bcc_table 

--計算盤存到資料之前的入領料 
declare bcc_table cursor for 
select storeno,bccno,bccname,datea,mount,total from @t_result 
open bcc_table 
fetch next from bcc_table 
into @storeno,@bccno,@bccname,@datea,@mount,@total 
while(@@FETCH_STATUS <> -1) 
begin 
--計算入庫平均單價
set @t_price=isnull((select sum(b.total)
from bccin a left join bccins b on a.noa=b.noa 
where b.bccno=@bccno and a.datea > @datea and a.datea< @t_bdate and b.storeno=@storeno
group by b.bccno),0)  /nullif(isnull((select sum(b.mount) mount 
from bccin a left join bccins b on a.noa=b.noa 
where b.bccno=@bccno and a.datea > @datea and a.datea< @t_bdate and b.storeno=@storeno
group by b.bccno),0) ,0)

--計算價錢 
set @t_total=@total+ 
--入料 
isnull((select sum(b.total) total 
from bccin a left join bccins b on a.noa=b.noa 
where b.bccno=@bccno and a.datea > @datea and a.datea< @t_bdate and b.storeno=@storeno
group by b.bccno),0) 
-
isnull((select sum((b.mount-b.bkbcc)*@t_price) total 
from bccout a left join bccouts b on a.noa=b.noa 
where b.bccno=@bccno and a.datea > @datea and a.datea< @t_bdate and b.storeno=@storeno
group by b.bccno),0) 


--計算庫存 
set @t_mount=@mount+ 
--入料 
isnull((select sum(b.mount) mount 
from bccin a left join bccins b on a.noa=b.noa 
where b.bccno=@bccno and a.datea > @datea and a.datea< @t_bdate and b.storeno=@storeno
group by b.bccno),0) 
--領料&繳回 
-isnull((select sum(b.mount-b.bkbcc) mount1 
from bccout a left join bccouts b on a.noa=b.noa 
where b.bccno=@bccno and a.datea > @datea and a.datea< @t_bdate and b.storeno=@storeno
group by b.bccno),0) 

--存入有盤存的庫存 
insert into @tmp 
select @storeno,'0',' 庫存',@bccno,@bccname,round(@t_total/nullif(@t_mount,0),0),0,0,@t_mount,'','' 
set @t_total=0 
set @t_mount=0 
fetch next from bcc_table 
into @storeno,@bccno,@bccname,@datea,@mount,@total 
end 
close bcc_table 
deallocate bcc_table 

--***************************************************************

--計算沒有盤存的庫存 

declare bcc_table cursor for 
select b.noa,a.noa,a.product from bcc a,store b where a.noa between @t_bbccno and @t_ebccno and a.noa+'-'+b.noa not in 
(select bccno+'-'+storeno from @tmp) 
and a.noa between @t_bbccno and @t_ebccno 
open bcc_table 
fetch next from bcc_table 
into @storeno,@bccno,@bccname
while(@@FETCH_STATUS <> -1) 
begin 
--計算入庫平均單價
set @t_price=isnull((select sum(b.total)  
from bccin a left join bccins b on a.noa=b.noa 
where b.bccno=@bccno and a.datea < @t_bdate and b.storeno=@storeno
group by b.bccno),0) /nullif(isnull((select sum(b.mount)  
from bccin a left join bccins b on a.noa=b.noa 
where b.bccno=@bccno and a.datea < @t_bdate and b.storeno=@storeno
group by b.bccno),0) ,0)


--計算價錢 
set @t_total= 
--入料 
isnull((select sum(b.total) total 
from bccin a left join bccins b on a.noa=b.noa 
where b.bccno=@bccno and a.datea < @t_bdate and b.storeno=@storeno
group by b.bccno),0) 
-
isnull((select sum((b.mount-b.bkbcc)*@t_price) total 
from bccout a left join bccouts b on a.noa=b.noa 
where b.bccno=@bccno and a.datea < @t_bdate and b.storeno=@storeno
group by b.bccno),0) 

--計算庫存 
set @t_mount= 
--入料 
isnull((select sum(b.mount) mount 
from bccin a left join bccins b on a.noa=b.noa 
where b.bccno=@bccno and a.datea < @t_bdate and b.storeno=@storeno
group by b.bccno),0) 
--領料&繳回 
-isnull((select sum(b.mount-b.bkbcc) mount1 
from bccout a left join bccouts b on a.noa=b.noa 
where b.bccno=@bccno and a.datea < @t_bdate and b.storeno=@storeno
group by b.bccno),0) 
--存入沒有盤存的庫存 
insert into @tmp 
select @storeno,'0',' 庫存',@bccno,@bccname,round(@t_total/nullif(@t_mount,0),0),0,0,@t_mount,'','' 

set @t_total=0 
set @t_mount=0 

fetch next from bcc_table 
into @storeno,@bccno,@bccname

end 
close bcc_table 
deallocate bcc_table 


--插入進出貨明細 
insert into @tmp 
select b.storeno,'0',a.datea,b.bccno,b.bccname,b.price,b.mount,null,null,null,b.memo 
from bccin a left join bccins b on a.noa=b.noa 
where a.datea between @t_bdate and @t_edate and  b.bccno between @t_bbccno and @t_ebccno

insert into @tmp 
select b.storeno,'0',a.datea,b.bccno,b.bccname,null,null,b.mount-b.bkbcc,null,a.sname,b.memo 
from bccout a left join bccouts b on a.noa=b.noa 
where a.datea between @t_bdate and @t_edate and  b.bccno between @t_bbccno and @t_ebccno

declare @result table(
	storeno nvarchar(20),
	gno nvarchar(1), 
	datea nvarchar(10), 
	bccno nvarchar(20), 
	bccname nvarchar(50), 
	price float, 
	inmount decimal (14,2), 
	outmount decimal (14,2), 
	stkmount decimal (14,2), 
	usename nvarchar(20), 
	memo nvarchar (200),
	sp nvarchar (1)
) 
insert into @result 
select *,'0' from @tmp order by storeno,bccno,datea 


--更新庫存量 

declare @inmount decimal (14,2) 
declare @outmount decimal (14,2) 
declare @stkmount decimal (14,2) 
declare @t_stkmount decimal (14,2) 

set @t_stkmount=0 

declare bcc_table cursor for 
select datea,bccno,inmount,outmount,stkmount from @result 
open bcc_table 
fetch next from bcc_table 
into @datea,@bccno,@inmount,@outmount,@stkmount 
while(@@FETCH_STATUS <> -1) 
begin 
if(@datea=' 庫存') 
begin 
set @t_stkmount=@stkmount 
end 
else 
begin 
update @result 
set stkmount=@t_stkmount+isnull(@inmount,0)-isnull(@outmount,0)	where current of bcc_table	
set @t_stkmount=@t_stkmount+isnull(@inmount,0)-isnull(@outmount,0) 
end 

fetch next from bcc_table 
into @datea,@bccno,@inmount,@outmount,@stkmount 
end 
close bcc_table 
deallocate bcc_table 

insert into @result 
select a.storeno,'1',null,a.bccno,b.product,null,null,null,null,null,null,'0' from @result a left join bcc b on a.bccno=b.noa group by a.storeno,a.bccno,b.product

insert into @result 
select storeno,'0',null,bccno,null,null,null,null,null,null,null,'1' from @result group by storeno,bccno
insert into @result 
select storeno,'0',null,bccno,null,null,null,null,null,null,null,'1' from @result group by storeno,bccno
update @result 
set bccname=null where datea=' 庫存'


-------------不要讓同一個資材拆成兩頁
declare @space bit	
declare @count int
declare	@t_bccno nvarchar(20)
declare	@t_bccno2 nvarchar(20)
declare	@t_bccno33 nvarchar(20)
declare	@gno nvarchar(1)
declare	@t_gno nvarchar(1)
declare	@x_storeno nvarchar(20)
set @space=1
set @t_bccno='XXXX'
set @t_bccno2='YYYY'
set @x_storeno='ZZZZZ'

	set @count=0
	declare bcc_table cursor for 
	select storeno,gno,bccno from @result order by storeno,bccno,gno desc ,sp
	open bcc_table 
	fetch next from bcc_table 
	into @storeno,@gno,@bccno
	while(@@FETCH_STATUS <> -1) 
	begin
		if (@x_storeno='ZZZZZ')
			set @x_storeno=@storeno
		set @count=@count+1
		if(@gno='1')
			set @count=@count+1
		if(@count>39 or @storeno!=@x_storeno)
		begin
			insert into @result 
			select @storeno,'2',null,@bccno,null,null,null,null,null,null,null,'1'
			set @count=0
		end
		if (@x_storeno!=@storeno)
			set @x_storeno=@storeno
		fetch next from bcc_table 
		into @storeno,@gno,@bccno
	end 
	close bcc_table 
	deallocate bcc_table 


-------------------
if(@t_storeno='99')
select store,gno,a.datea,bccno,bccname,usename,memo,
reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,price),1)),4,12)) price,
reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,inmount),1)),4,12)) inmount,
reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,outmount),1)),4,12)) outmount,
reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,stkmount),1)),4,12)) stkmount
from @result a left join store b on a.storeno=b.noa order by storeno,bccno,gno desc,sp
else
select store,gno,a.datea,bccno,bccname,usename,memo,
reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,price),1)),4,12)) price,
reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,inmount),1)),4,12)) inmount,
reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,outmount),1)),4,12)) outmount,
reverse(substring(reverse(convert(nvarchar(15),CONVERT(money,stkmount),1)),4,12)) stkmount
from @result a left join store b on a.storeno=b.noa where storeno=@t_storeno order by storeno,bccno,gno desc,sp;